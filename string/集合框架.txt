集合类的由来：
	对象由于封装特有的数据，对象多了需要存储，如果对象的个数不确定
	就使用集合容器进行存储
	
集合的特点：
1. 用于存储对象的容器
2. 集合的长度是可变的
3. 集合中不可以存储基本数据类型值

Collection  向上抽取的共性内容 --- 接口 表示一组对象

java.util java的工具包

集合容器因为内部的数据结构不同，有多种具体容器
不断向上抽取，就形成了集合框架

框架的顶层Collection接口
Collection的常见方法：
1. 添加
	boolean add(Object obj)			 添加一个
	boolean addAll(Collection coll)  添加全部
	
2. 删除
	boolean remove(object obj)
	boolean removeAll(Collection coll)  仅移除次此collection中哪些也包含指定collection中的所有元素
	void clear();
3. 判断
	boolean contains(object obj)
	boolean containAll(Collection coll)
	boolean isEmpty()   判断集合中是否有元素
4. 获取
	int size() 返回collection中的元素数
	Iterator iterator() 取出元素的方式：迭代器
	该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。
	所以该迭代器对象是在容器中进行内部实现的。
	对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器对象即可
	也就是iterator方法
	
5. 其他
	boolean retainAll(Collection coll) 取交集
	Object[] toArray() 将集合转成数组


------------------------------------------------------------------

Collection
1. List(): 有序（存入和取出的顺序一致），元素都有索引，元素可以重复
2. Set()：元素不能重复。


List：特有的常见方法：共性特点就是都可以操作角标
1. 添加
	void add(index,element);
	void add(index,collection)
2. 删除
	Object remove(index)
3. 修改
	Object set(index,element)
4. 获取
	Object get(index);
	int indexOf(Object)
	int lastIndexOf(Object)
	List subList(fromIndex,toIndex) 包含头不包含尾
	
List集合是可以完成对元素的增删改查。
在迭代器过程中，不要使用机和操作元素，容易出现异常
可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作

List：常用子类对象
1. Vector：内部是数组数据结构，是同步的，效率低  增删查询都很慢--- 几乎不用
2. ArrayList：内部是数组数据结构，是不同步的，效率高，替代了Vector --- 查询的速度快
3. LinkedList：list接口的链接列表实现，是不同步的，增删元素的速度很快。

LinkedList：
	addFirst();
	addLast();
	
	removeFirst();
	removeLast();
	jdk1.6
	pollFirst();
	pollLast();
	
	getFirst();
	getLast();
	jdk1.6:
	peekFirst();
	peekLast();

------------------------------------------

Set：元素不可以重复，是无序的
	Set接口中的方法和Collection一致。
	
	子类对象：
		 HashSet: 内部数据结构是哈希表，是不同步的。
		 	哈希表确定元素是否相同：
		 		1. 判断的是两个元素的哈希值是否相同
		 			如果相同，在判断两个对象的内容是否相同
		 		2. 判断哈希值相同，其判断的是对象的hashcode的方法。
		 			判断内容相同，用的是equals方法。
		 		注意：如果哈希值不同，是不需要判断equals。
		 		
		 TreeSet：可以使用元素的自然顺序对元素进行排序。
		 		     即可以对Set集合中的元素进行排序，是不同步的.
				判断元素唯一性的方式：根据比较方法的返回结果是否是0，是0，就是相同元素。就不会存。
				
				TreeSet对元素进行排序的方式一：
				让元素自身具备比较功能，就需要实现Comparable接口，覆盖compareTo方法。
				
				如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序，怎么办？
				
				可以使用TreeSet集合的第二种排序方式：
				让集合自身具备比较功能,定义一个类实现Comparator接口，覆盖compara方法
				将该类对象作为参数传递给TreeSet集合的构造函数。
				
			二叉树
			
看到array：就要想到数组，就要想到查询快，有角标
看到link：就要想到链表，就要想到增删快，就要想到add get remove+first/last的方法
看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法
看到tree：就要想到二叉树，就要想到排序，就要想到两个接口 Comparable , Comparator

而且通常这些常用的集合容器都是不同步的。

-----------------------------------------------------------------------------------

Map：一次添加一对元素，collection一次添加一个元素
	Map也称为双列集合，collection集合称为单列集合。
	其实map集合中存储的就是键值对。
	map集合中必须保证键的唯一性。

常用方法：
1. 添加
		value put(key,value):返回前一个和key关联的值，如果没有就返回null

2. 删除
		void clear():清空map集合
		value remove(key):根据指定的key删除这个键值对

3. 判断
		boolean containKey(key)
		boolean containsValue(value)
		boolean isEmpty()

4. 获取
		value get(key):通过键获取值，如果没有该键返回null
						当然可以通过返回null，来判断是否包含指定键。
		int size():获取键值对的个数
		
		
Map常用的子类：
	1. Hashtable：内部结构是哈希表，是同步的。不允许null作为键/值
		1.Properties:用来存储键值对型的配置文件的信息，可以和IO技术相结合
	2. HashMap：内部结构是哈希表，不是同步的。允许null作为键/值
	3. TreeMap: 内部结构是二叉树，不是同步的，可以对键和值进行排序
	
----------------------------------------------------------------------

List list = new ArrayList(); //非同步的

List = MyCollections.synList(list); //同步的
	
	
给非同步的集合加锁。

class MyCollections{

	public List synList(List list){
		return MyList(list);
	}

}

class MyList{
	
	private List list;
	
	private static final Object lock = new Object();
	MyList(List list){
		this.list = list;
	}

	public boolean add(Object obj){
		synchronized(lock){
			return list.add(obj);
		}
	
	}
	
	public boolean remove(Object obj){
		synchronized(lock){
			return list.remove(obj);
		}
	}
}	
	

泛型：
	jdk1.5出现的新特性 --- 安全机制。

好处：
	1. 将运行时期的问题ClassCastException转到了编译时期。
	2. 避免了强制转换的麻烦。

<>：什么时候用呢？当操作的引用数据类型不确定的时候。就用<>，将要操作的引用数据传入即可。
	其实<>就是一个用于接收具体引用数据类型的参数范围。
	
在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型。

泛型技术是编译时期使用的，定义容器的时候就明确类型。

运行时，会将泛型去掉，生成的class文件中是不带泛型的。这个称之为泛型的擦除。	
为什么擦除呢？因为为了兼容运行运的类加载器。

泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。	
	
//将泛型定义在方法上
	
	public <W> void show(W str){
		System.out.println("show:" + str.toString);
	}
	
//当方法是静态的时候，不能访问类上定义的泛型。如果静态方法使用泛型，只能将泛型定义在方法上
	
	public static <Y> void method(Y obj){
		System.out.println("method:" + obj);
	}
	
//泛型接口

	interface Inter<T>{
		public void show();
	}
	
	class InterImp1 implements Inter<String>{
		public void show(String str){
			System.out.println("show:" + str);
		}
	}
	
	public InterImpl2 <Q> implements Inter<Q>{
		public void show(Q q){
			System.out.println("show:" + q);
		}
	}
	
	//main
	public static void main(String[] args){
	
		InterImpl1 in = new InterIm1();
		in.show("abc");
		
		InterImpl2<Integer> in2 = new InterIm2<Integer>();
		in.show(5);
		
	}
	
	
集合的通配符：? 未知类型
	public static void printCollection(Collection<?> a1){
		
		Iterator<?> it = a1.iterator();
		
		while(it.hasNext){
			System.out.println(it.next()); 
		}
		
	}
	
	
对类型进行限定：
? extends E:接收E类型或者E的子类型对象。上限。
? super E:接收E类型或者E的父类型。下限。

一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。
什么时候用下限呢？通常对集合中的元素进行取出操作时，可以用下限。


------------------------------------------------------------------
总结：
需要唯一吗？
需要：Set
	需要指定顺序吗？
			需要：TreeSet
			不需要：HashSet
			想要和存储顺序一致的：LinkedHashSet

不需要：List
	需要频繁增删吗？
			需要：LinkedList
			不需要：ArrayList

如何记录每一个容器的结构和所属体系呢？

看名字！


List
	|--ArrayList
	|--LinkedList
Set
	|--HashSet
	|--TreeSet
后缀名就是该集合所属的体系。

前缀名就是该集合的数据结构。

看到arrays：就要想到数据，就要查到查询快，有角标。
看到link：就要想到链表，就要想到增删快，就要想到add get remove+first/last
看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode equals方法
看到tree：就要想到树 --- 二叉树，就要想到排序，就要想到两个接口Comparable Comparator

而且通常这些常用的容器都是不同步的。




























	
	
	
	
	
	
	
	
	